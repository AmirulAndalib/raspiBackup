#!/bin/bash

# Just some code to get familiar with remote ssh command execution and rsync daemon

<<<<<<< HEAD
source ../../raspiBackup.sh --include
=======
declare -r PS4='|${LINENO}> \011${FUNCNAME[0]:+${FUNCNAME[0]}(): }'

source ./executeRemoteCommand.sh
>>>>>>> development

# @@@ test scenarios @@@
#
### Copy functions
#
# - Test File attributes and ACLs are transferred correctly
# - Test RCs are transferred correctly
#
## - Copy to remote -
# 1) Copy local files to other local destination
# 2) Copy local files to remote destination via ssh
# 3) Copy local files to remote destination via rsync daemon

## - Copy from remote -
# 1) Copy local files to other local destination
# 2) Copy remote files from remote destination to local via ssh (ACLs will not be preserved)
# 3) Copy remote files from remote destination to local via rsync daemon

# !!! - Test File attributes and ACLs are transferred correctly
# !!! - Test RCs are transferred correctly

### Command execution
#
# See https://stackoverflow.com/questions/11027679/capture-stdout-and-stderr-into-different-variables how to capture stdout and stderr and rc into different variables
#
## - local command execution -
# 1) Test local result (stdout and stderr) returned correctly
# 2) Test local RCs are returned correctly
#
## - remote command execution via ssh -
# 1) Test remote result (stdout and stderr) received correctly locally
# 2) Test remote execution RCs are returned correctly

source ~/.ssh/rsyncServer.creds
#will define
#SSH_HOST=
#SSH_USER= # pi
#SSH_KEY_FILE= # public key of user

#DAEMON_HOST=
#DAEMON_MODULE="Rsync-Test" # uses DAEMON_MODULE_DIR
#DAEMON_MODULE_DIR="/srv/rsync"
#DAEMON_USER=
#DAEMON_PASSWORD=

#
# Required access rights
#
# SSH
# 1) Local user (e.g. framp) calling script via sudo to connect to remote backup system has to have its public key in authorized_hosts of remote user (e.g. pi)
<<<<<<< HEAD
# 2) Remote user (e.g. pi) can call sudo
=======
# 2) Remote user (e.g. pi) can call sudo 
>>>>>>> development
#
# RSYNC
# 1) See access rights for SSH
# 2) Remote rsync server user has to have full access on module directory
#
# LOCAL_USER: SSH key access to SSH_USER@SSH_HOST
# SSH_USER: Can use sudo on remote host
#
# Suggestion: Use the same remote user for SSH and rsync module

<<<<<<< HEAD
=======
TEST_DIR="Test-Backup"

readonly TARGET_HOST="TARGET_HOST" # ssh and daemon
readonly TARGET_USER="TARGET_USER" # ssh and daemon
readonly TARGET_PASSWORD="TARGET_PASSWORD" # daemon
readonly TARGET_KEY="TARGET_KEY" # ssh
readonly TARGET_DAEMON_USER="TARGET_DAEMON_USER" # ssh and daemon
readonly TARGET_DAEMON_PASSWORD="TARGET_DAEMON_PASSWORD" # daemon
readonly TARGET_MODULE="TARGET_MODULE" # daemon
readonly TARGET_DIR="TARGET_DIR" # daemon

readonly TARGET_TYPE="TARGET_TYPE"
readonly TARGET_TYPE_DAEMON="TARGET_TYPE_DAEMON"
readonly TARGET_TYPE_SSH="TARGET_TYPE_SSH"
readonly TARGET_TYPE_LOCAL="TARGET_TYPE_LOCAL"

readonly TARGET_DIRECTION_TO="TARGET_DIRECTION_TO"	# from local to remote
readonly TARGET_DIRECTION_FROM="TARGET_DIRECTION_FROM" # from remote to local

declare -A localTarget
localTarget[$TARGET_TYPE]="$TARGET_TYPE_LOCAL"
localTarget[$TARGET_DIR]="./$TEST_DIR"

declare -A sshTarget
sshTarget[$TARGET_TYPE]="$TARGET_TYPE_SSH"
sshTarget[$TARGET_HOST]="$SSH_HOST"
sshTarget[$TARGET_USER]="$SSH_USER"
sshTarget[$TARGET_KEY]="$SSH_KEY_FILE"
sshTarget[$TARGET_DIR]="$DAEMON_MODULE_DIR/$TEST_DIR"

declare -A rsyncTarget
rsyncTarget[$TARGET_TYPE]="$TARGET_TYPE_DAEMON"
rsyncTarget[$TARGET_HOST]="$SSH_HOST"
rsyncTarget[$TARGET_USER]="$SSH_USER"
rsyncTarget[$TARGET_KEY]="$SSH_KEY_FILE"
rsyncTarget[$TARGET_DAEMON_USER]="$DAEMON_USER"
rsyncTarget[$TARGET_DAEMON_PASSWORD]="$DAEMON_PASSWORD"
rsyncTarget[$TARGET_MODULE]="$DAEMON_MODULE"
rsyncTarget[$TARGET_DIR]="$DAEMON_MODULE_DIR"

>>>>>>> development
RSYNC_OPTIONS="-aHAxvp --delete"

if (( $UID != 0 )); then
	echo "Call me as root"
	exit -1
fi

function checkrc() {
<<<<<<< HEAD
	logEntry "$1"
	local rc="$1"
	if (( $rc != 0 )); then
		echo "Error $rc"
		exit 1
	fi

	logExit $rc
=======
	if (( $1 != 0 )); then
		echo "Error $1"
		exit 1
	fi
>>>>>>> development
}

function createTestData() { # directory

	if [[ ! -d $1 ]]; then
		mkdir $1
	fi

	rm -f $1/acl.txt
	rm -f $1/noacl.txt

	touch $1/acl.txt
	setfacl -m u:$USER:rwx $1/acl.txt

	touch $1/noacl.txt

	verifyTestData "$1"
}

function verifyTestData() { # directory

	./testRemote.sh "$1"

}

function getRemoteDirectory() { # target directory

	local -n target=$1

	case ${target[$TARGET_TYPE]} in

		$TARGET_TYPE_SSH | $TARGET_TYPE_DAEMON)
			echo "${target[$TARGET_DIR]}"
			;;

		*) echo "Unknown target ${target[$TARGET_TYPE]}"
			exit -1
			;;
	esac
}

<<<<<<< HEAD
function testCommand() {

	logEntry

	local reply rc
=======
# invoke command either local, remote via ssh or on rsync daemon directory
function invokeCommand() { # target command

	local rc reply std err

	local -n target=$1

	case ${target[$TARGET_TYPE]} in

		$TARGET_TYPE_LOCAL)
			reply="$($2)"
			rc=$?
			echo "$reply"
			;;

		$TARGET_TYPE_SSH | $TARGET_TYPE_DAEMON)
			executeRemoteCommand std err "ssh ${target[$TARGET_USER]}@${target[$TARGET_HOST]} -i ${target[$TARGET_KEY]} $2"
			rc=$?
			echo "$std"
			;;

		*) echo "Unknown target ${target[$TARGET_TYPE]}"
			exit -1
			;;

	esac

	return $rc
}

function invokeRsync() { # target direction from to

	local rc reply direction fromDir toDir command module

	local -n target=$1

	shift
	direction="$1"
	fromDir="$2"
	toDir="$3"

	# echo "-> Dir: $direction: From: $fromDir to: $toDir " $LOG

	case ${target[$TARGET_TYPE]} in

		$TARGET_TYPE_LOCAL)
			echo "local targethost: $(hostname)" $LOG
			reply="$(rsync $RSYNC_OPTIONS $fromDir $toDir)"
			rc=$?
			checkrc $rc
			# echo -e "RC: $rc\n$reply" $LOG
			;;

		$TARGET_TYPE_SSH)
			echo "SSH targethost: ${target[$TARGET_USER]}@${target[$TARGET_HOST]}" $LOG
			if [[ $direction == $TARGET_DIRECTION_TO ]]; then
				reply="$(rsync $RSYNC_OPTIONS -e "ssh -i ${target[$TARGET_KEY]}" --rsync-path='sudo rsync' $fromDir ${target[$TARGET_USER]}@${target[$TARGET_HOST]}:/$toDir)"
			else
				reply="$(rsync $RSYNC_OPTIONS -e "ssh -i ${target[$TARGET_KEY]}" --rsync-path='sudo rsync' ${target[$TARGET_USER]}@${target[$TARGET_HOST]}:/$fromDir $toDir)"
			fi
			rc=$?
			checkrc $rc
			# echo -e "RC $rc:\n$reply" $LOG
			;;

		$TARGET_TYPE_DAEMON)
			echo "daemon targethost: ${target[$TARGET_DAEMON_USER]}@${target[$TARGET_HOST]}" $LOG
			export RSYNC_PASSWORD="${target[$TARGET_DAEMON_PASSWORD]}"
			module="${target[$TARGET_MODULE]}"
			if [[ $direction == $TARGET_DIRECTION_TO ]]; then
				reply="$(rsync $RSYNC_OPTIONS $fromDir rsync://"${target[$TARGET_DAEMON_USER]}"@${target[$TARGET_HOST]}:/$module)" # toDir is actually the rsync server module
			else
				reply="$(rsync $RSYNC_OPTIONS rsync://"${target[$TARGET_DAEMON_USER]}"@${target[$TARGET_HOST]}:/$module $toDir)"
			fi
			rc=$?
			checkrc $rc
			#echo -e "RC $rc:\n$reply" $LOG
			;;

		*) echo "Unknown target ${target[$TARGET_TYPE]}"
			exit -1
			;;
	esac

	return $rc
}

function testCommand() {

	local reply
>>>>>>> development

	echo "@@@ testCommand @@@"

	declare t=(localTarget sshTarget)

<<<<<<< HEAD
	cmds=("ls -la /" "sudo cat /etc/shadow")

	for (( target=0; target<${#t[@]}; target++ )); do
		tt="${t[$target]}"
		echo "@@@ ---> Target: $tt"
		for cmd in "${cmds[@]}"; do
			echo "Command: $cmd "
			reply="$(invokeCommand ${t[$target]} "$cmd")"
			rc=$?
			checkrc $rc
			logItem "$reply"
		done
		echo
	done

	logExit $rc
=======
	for (( target=0; target<${#t[@]}; target++ )); do
		tt="${t[$target]}"
		echo "@@@ Target: $tt"
		reply="$(invokeCommand ${t[$target]} "ls -la /")"
		echo "Reply: $reply"
		echo "RC: $?"
	done

	if [[ -e $LOGFILE ]]; then
		echo "+========================"
		cat $LOGFILE
		echo "-========================"
		rm -f $LOGFILE
	fi

>>>>>>> development
}

function testRsync() {

	local reply

	echo "@@@ testRsync @@@"

<<<<<<< HEAD
	declare t=(localTarget sshTarget rsyncTarget)

	for (( target=2; target<${#t[@]}; target++ )); do

		tt="${t[$target]}"
		echo
		echo "@@@ ---> Target: $tt"

		echo "@@@ Creating test data in local dir"
		if [[ $tt == "localTarget" ]]; then
			targetDir="${TEST_DIR}_tgt"
			mkdir -p $targetDir
		else
			targetDir="$(getRemoteDirectory "${t[$target]}" $TARGET_DIR)"
		fi
		createTestData $TEST_DIR

		echo "@@@ Copy local data to remote"
		invokeRsync ${t[$target]} "$RSYNC_OPTIONS" $TARGET_DIRECTION_TO "$TEST_DIR/" "$targetDir"
		checkrc $?
		logItem "$reply"
=======
	declare t=(sshTarget rsyncTarget)

	for (( target=0; target<${#t[@]}; target++ )); do

		tt="${t[$target]}"
		echo "@@@ Target: $tt"

		echo "@@@ Creating test data in local dir"
		targetDir="$(getRemoteDirectory "${t[$target]}" $TARGET_DIR)"

		createTestData $TEST_DIR

		echo "@@@ Copy local data to remote"
		invokeRsync ${t[$target]} $TARGET_DIRECTION_TO "$TEST_DIR/" "$targetDir"
		checkrc $?
>>>>>>> development

		echo "@@@ Verify remote data"
#		See https://unix.stackexchange.com/questions/87405/how-can-i-execute-local-script-on-remote-machine-and-include-arguments
		printf -v args '%q ' "$targetDir"
		reply="$(invokeCommand ${t[$target]} "bash -s -- $args"  < ./testRemote.sh)"
<<<<<<< HEAD
		checkrc $?
		logItem "$reply"
=======
>>>>>>> development

		# cleanup local dir
		echo "@@@ Clear local data"
		rm ./$TEST_DIR/*

		echo "@@@ Copy remote data to local"
<<<<<<< HEAD
		reply="$(invokeRsync ${t[$target]} "$RSYNC_OPTIONS" $TARGET_DIRECTION_FROM "$targetDir/" "$TEST_DIR")"
		checkrc $?
		logItem "$reply"
=======
		reply="$(invokeRsync ${t[$target]} $TARGET_DIRECTION_FROM "$targetDir/" "$TEST_DIR")"
		checkrc $?
>>>>>>> development

		echo "@@@ Verify local data"
		verifyTestData "$TEST_DIR"

<<<<<<< HEAD
		echo "@@@ Remote data"
		reply="$(invokeCommand ${t[$target]} "ls -la "$targetDir/*"")"
		logItem "$reply"

		echo "@@@ Clear remote data"
		reply="$(invokeCommand ${t[$target]} "rm "$targetDir/*"")"
		logItem "$reply"

		echo "@@@ Remote data cleared"
		reply="$(invokeCommand ${t[$target]} "ls -la "$targetDir"")"
		logItem "$reply"

#		remote error

		echo "@@@ Error"
		replay="$(invokeRsync ${t[$target]} "$RSYNC_OPTIONS" $TARGET_DIRECTION_TO "${TEST_DIR}Dummy/" "${targetDir}Dummy")"
		checkrc $?
		logItem "$reply"

	done

=======
		echo "@@@ Clear remote data"
		reply="$(invokeCommand ${t[$target]} "rm "$targetDir/$TEST_DIR/*"")"
		echo "$reply"
		
		echo "@@@ Remote data cleared"
		reply="$(invokeCommand ${t[$target]} "ls -la "$targetDir/$TEST_DIR/*"")"
		echo "$reply"

	done

	if [[ -e $LOGFILE ]]; then
		echo "+========================"
		cat $LOGFILE
		echo "-========================"
		rm -f $LOGFILE
	fi

>>>>>>> development
}

reset
testRsync
<<<<<<< HEAD
#testCommand


=======
testCommand
>>>>>>> development
